TRIAL_INDEX=seq(1:numberOfTrials),
CURRENT_MSG_INDEX=seq(1),
CURRENT_MSG_TEXT=eventNames)
)[order(RECORDING_SESSION_LABEL, TRIAL_INDEX, CURRENT_MSG_INDEX)]
mDT[,CURRENT_MSG_INDEX:=cumsum(CURRENT_MSG_INDEX),list(RECORDING_SESSION_LABEL,TRIAL_INDEX)]
mDT[CURRENT_MSG_TEXT=='DISPLAY_START',CURRENT_MSG_TIME:=25+sample(seq(1:10),1),
list(RECORDING_SESSION_LABEL, TRIAL_INDEX)]
mDT[CURRENT_MSG_TEXT=='DISPLAY_CHANGE',CURRENT_MSG_TIME:=250+sample(seq(1:10),1),
list(RECORDING_SESSION_LABEL, TRIAL_INDEX)]
bDT <- xDT[CURRENT_FIX_BUTTON_7_PRESS!='.' | CURRENT_FIX_BUTTON_8_PRESS!='.',
list(CURRENT_MSG_TEXT='BUTTON_PRESS', CURRENT_MSG_INDEX=3),
list(RECORDING_SESSION_LABEL,TRIAL_INDEX,
RESPONSE_BUTTON_PRESSED,CURRENT_FIX_BUTTON_7_PRESS,
CURRENT_FIX_BUTTON_8_PRESS)]
bDT[RESPONSE_BUTTON_PRESSED==7,CURRENT_MSG_TIME:=CURRENT_FIX_BUTTON_7_PRESS,]
bDT[RESPONSE_BUTTON_PRESSED==8,CURRENT_MSG_TIME:=CURRENT_FIX_BUTTON_8_PRESS,]
bDT$RESPONSE_BUTTON_PRESSED<-NULL
bDT$CURRENT_FIX_BUTTON_7_PRESS<-NULL
bDT$CURRENT_FIX_BUTTON_8_PRESS<-NULL
# FINALISE MESSAGE REPORT
mDT <- data.table(rbind(mDT,bDT))[order(RECORDING_SESSION_LABEL, TRIAL_INDEX, CURRENT_MSG_INDEX)]
write.table(xDT, 'fixationreport.txt',row.names=F, sep='\t')
write.table(mDT, 'messagereport.txt',row.names=F, sep='\t')
fixreport <- xDT
messagereport <- mDT
save(fixreport, file = 'fixreport.RData')
save(messagereport, file = 'messagereport.RData')
# MARKUP UP SAVE FINAL TABLE FOR ANALYSIS
# LOAD FILES ##############################################################################################################################################################
messagereport <- read.table("messagereport.txt", header=T, quote="\"")
fixreport <- read.table("fixationreport.txt", header=T, quote="\"")
# LOAD FUNCTIONS ##############################################################################################################################################################
library(eyeTrackR)
# DO MARKUP ##############################################################################################################################################################
# REPLACE SPACES IN MESSAGES
messagereport <- organise.message.replace_spaces(messagereport)
# TAKE A LOOK
organise.message.descriptives(messagereport)
# MARKUP
foo <- organise.message.markup(message_df=messagereport, fixreport_df = fixreport, message="DISPLAY_START")
foo <- organise.message.markup(message_df=messagereport, fixreport_df = foo, message="DISPLAY_CHANGE")
# NOW DO ACCURACY AND RT MARKUP
#foo$CORRECT_ANSWER <- as.numeric(as.character(foo$CORRECT_ANSWER))
foo <- organise.responses.markup(foo, "CORRECT_RESPONSE")
# NOW MARK UP FIXATION CONTINGENCIES
foo<-organise.message.fix_contingencies(foo, list("DISPLAY_START", "DISPLAY_CHANGE", "RESPONSE_TIME"))#, "RESPONSE", "TRIAL_END", "TRIAL_RESULT_0"))
# RANDOM TRIAL TO CHECK THINGS OUT
organise.checks.random_trial(foo)
#foo[FIXATION_CONTINGENCY=='UNCLASSIFIED',,]
#a <- foo[RECORDING_SESSION_LABEL==13 & TRIAL_INDEX==11,,]
# FIX CONTINGENCIES
organise.contingencies.descriptives(foo)
# REMOVE MISSING EVENTS - HERE, TRIALS WHICH LACKED A RESPOSNE
foo <- organise.message.removals(fixreport_df=foo, required_message_list=list("DISPLAY_CHANGE", "RESPONSE_TIME"))
organise.contingencies.descriptives(foo) # THIS SHOWS WE HAVE NO UNCLASSIFIED FIXATIONS, GOOD!
# REMOVALS
df_final_for_analysis <- organise.exclusions.fix_durations(fixreport_df=foo)
# THAT'S IT! LET'S NOW SAVE THE FINAL THING ##############################################################################################################################################################
write.table(df_final_for_analysis, "df_final_for_analysis.txt", row.names=FALSE)
save(df_final_for_analysis, file='df_final_for_analysis.RData')
library(eyeTrackR)
set.seed(3005)
# SETUP KEY VARIABLES
numberOfTrials <- 500
numberOfParticipants <- 30
conditionNames <- c('Easy','Hard')
meanFixDuration <- 120
sdFixDuration <- 30
meanSacAmplitude <- 2
sdSacAmplitude <- 0.1
eventNames <- c('DISPLAY_START','DISPLAY_CHANGE')
#eventTimeMeans <-c(100,250,750)
#eventTimeSDs <- c(0,0,50)
# CREATE BASE DATA TABLE
xDT <- data.table(expand.grid(
RECORDING_SESSION_LABEL=seq(1:numberOfParticipants),
TRIAL_INDEX=seq(1:numberOfTrials),
CURRENT_FIX_INDEX=seq(1:20))
)[order(RECORDING_SESSION_LABEL, TRIAL_INDEX, CURRENT_FIX_INDEX)]
# SET CORRECT RESPONSES
xDT[TRIAL_INDEX %between% c(1,numberOfTrials/2),CORRECT_RESPONSE:=7,]
xDT[TRIAL_INDEX %between% c(numberOfTrials/2,numberOfTrials),CORRECT_RESPONSE:=8,]
# BASIC FIXATION INFORMATION
xDT[,CURRENT_FIX_DURATION:=runif(min = meanFixDuration - sdFixDuration, max= meanFixDuration + sdFixDuration, n = nrow(xDT)),]
xDT[,PREVIOUS_FIX_DURATION:=shift(CURRENT_FIX_DURATION,1),list(RECORDING_SESSION_LABEL,TRIAL_INDEX)]
xDT[CURRENT_FIX_INDEX==1,PREVIOUS_FIX_DURATION:=0,]
xDT[,CURRENT_FIX_START:=cumsum(PREVIOUS_FIX_DURATION),list(RECORDING_SESSION_LABEL,TRIAL_INDEX)]
xDT[,CURRENT_FIX_END:=CURRENT_FIX_START+CURRENT_FIX_DURATION,]
# BASIC SACCADE AMPLITUDE INFORMATION
xDT[,NEXT_SAC_AMPLITUDE:=rnorm(meanSacAmplitude,sdSacAmplitude, n=nrow(xDT)),]
# BUTTON PRESSES
xDT[,FIX_INDEX_BUTTON_PRESS:=sample(seq(from=5, to = 15, by =1),1),list(RECORDING_SESSION_LABEL,TRIAL_INDEX)]
xDT[,RESPONSE_BUTTON_PRESSED:=sample(seq(7,8),1),list(RECORDING_SESSION_LABEL,TRIAL_INDEX)]
xDT$CURRENT_FIX_BUTTON_0_PRESS <- '.'
xDT$CURRENT_FIX_BUTTON_1_PRESS <- '.'
xDT$CURRENT_FIX_BUTTON_2_PRESS <- '.'
xDT$CURRENT_FIX_BUTTON_3_PRESS <- '.'
xDT$CURRENT_FIX_BUTTON_4_PRESS <- '.'
xDT$CURRENT_FIX_BUTTON_5_PRESS <- '.'
xDT$CURRENT_FIX_BUTTON_6_PRESS <- '.'
xDT[CURRENT_FIX_INDEX==FIX_INDEX_BUTTON_PRESS & RESPONSE_BUTTON_PRESSED==7,
CURRENT_FIX_BUTTON_7_PRESS:=sample(seq(from=CURRENT_FIX_START, to=CURRENT_FIX_END,by=1),1),
list(RECORDING_SESSION_LABEL,TRIAL_INDEX)]
xDT[CURRENT_FIX_INDEX==FIX_INDEX_BUTTON_PRESS & RESPONSE_BUTTON_PRESSED==8,
CURRENT_FIX_BUTTON_8_PRESS:=sample(seq(from=CURRENT_FIX_START, to=CURRENT_FIX_END,by=1),1),
list(RECORDING_SESSION_LABEL,TRIAL_INDEX)]
xDT$CURRENT_FIX_BUTTON_7_PRESS <- as.character(xDT$CURRENT_FIX_BUTTON_7_PRESS)
xDT$CURRENT_FIX_BUTTON_8_PRESS <- as.character(xDT$CURRENT_FIX_BUTTON_8_PRESS)
xDT[is.na(CURRENT_FIX_BUTTON_7_PRESS)==T,CURRENT_FIX_BUTTON_7_PRESS:='.',]
xDT[is.na(CURRENT_FIX_BUTTON_8_PRESS)==T,CURRENT_FIX_BUTTON_8_PRESS:='.',]
# KEEP ONLY ACTUAL DATA
xDT <- xDT[CURRENT_FIX_INDEX<=FIX_INDEX_BUTTON_PRESS,,]
# NOW MAKE MESSAGE REPORT
mDT <- data.table(expand.grid(
RECORDING_SESSION_LABEL=seq(1:numberOfParticipants),
TRIAL_INDEX=seq(1:numberOfTrials),
CURRENT_MSG_INDEX=seq(1),
CURRENT_MSG_TEXT=eventNames)
)[order(RECORDING_SESSION_LABEL, TRIAL_INDEX, CURRENT_MSG_INDEX)]
mDT[,CURRENT_MSG_INDEX:=cumsum(CURRENT_MSG_INDEX),list(RECORDING_SESSION_LABEL,TRIAL_INDEX)]
mDT[CURRENT_MSG_TEXT=='DISPLAY_START',CURRENT_MSG_TIME:=25+sample(seq(1:10),1),
list(RECORDING_SESSION_LABEL, TRIAL_INDEX)]
mDT[CURRENT_MSG_TEXT=='DISPLAY_CHANGE',CURRENT_MSG_TIME:=250+sample(seq(1:10),1),
list(RECORDING_SESSION_LABEL, TRIAL_INDEX)]
bDT <- xDT[CURRENT_FIX_BUTTON_7_PRESS!='.' | CURRENT_FIX_BUTTON_8_PRESS!='.',
list(CURRENT_MSG_TEXT='BUTTON_PRESS', CURRENT_MSG_INDEX=3),
list(RECORDING_SESSION_LABEL,TRIAL_INDEX,
RESPONSE_BUTTON_PRESSED,CURRENT_FIX_BUTTON_7_PRESS,
CURRENT_FIX_BUTTON_8_PRESS)]
bDT[RESPONSE_BUTTON_PRESSED==7,CURRENT_MSG_TIME:=CURRENT_FIX_BUTTON_7_PRESS,]
bDT[RESPONSE_BUTTON_PRESSED==8,CURRENT_MSG_TIME:=CURRENT_FIX_BUTTON_8_PRESS,]
bDT$RESPONSE_BUTTON_PRESSED<-NULL
bDT$CURRENT_FIX_BUTTON_7_PRESS<-NULL
bDT$CURRENT_FIX_BUTTON_8_PRESS<-NULL
# FINALISE MESSAGE REPORT
mDT <- data.table(rbind(mDT,bDT))[order(RECORDING_SESSION_LABEL, TRIAL_INDEX, CURRENT_MSG_INDEX)]
write.table(xDT, 'fixationreport.txt',row.names=F, sep='\t')
write.table(mDT, 'messagereport.txt',row.names=F, sep='\t')
fixationreport <- xDT
messagereport <- mDT
save(fixreport, file = 'fixationreport.RData')
save(messagereport, file = 'messagereport.RData')
library(eyeTrackR)
data("fixationreport")
print(organise.checks.random_trial(fixationreport))
library(eyeTrackR)
library(eyeTrackR)
data(fixationreport)
data(messagereport)
# REPLACE SPACES IN MESSAGES
messagereport <- organise.message.replace_spaces(messagereport)
# TAKE A LOOK
organise.message.descriptives(messagereport)
print(organise.message.descriptives(messagereport))
detach("package:eyeTrackR", unload = TRUE)
getwd
library(eyeTrackR)
getwd()
# TAKE A LOOK
organise.message.descriptives(messagereport)
# TAKE A LOOK
organise.message.descriptives(messagereport)
# MARKUP
fixationreport <- organise.message.markup(message_df=messagereport, fixreport_df = fixationreport, message="DISPLAY_START")
fixationreport <- organise.message.markup(message_df=messagereport, fixreport_df = fixationreport, message="DISPLAY_CHANGE")
# NOW DO ACCURACY AND RT MARKUP
#foo$CORRECT_ANSWER <- as.numeric(as.character(foo$CORRECT_ANSWER))
fixationreport <- organise.responses.markup(fixationreport, "CORRECT_RESPONSE")
# NOW MARK UP FIXATION CONTINGENCIES
fixationreport<-organise.message.fix_contingencies(fixationreport, list("DISPLAY_START", "DISPLAY_CHANGE", "RESPONSE_TIME"))#, "RESPONSE", "TRIAL_END", "TRIAL_RESULT_0"))
# SET UP TRUE RT
fixationreport[,TRUE_RT:=RESPONSE_TIME-DISPLAY_START,]
behaviouralData <- analyse.behavioural.data(fixationreport,
aggregation_column_list = list('TRIALTYPE_TEXT'))
# RANDOM TRIAL TO CHECK THINGS OUT
organise.checks.random_trial(fixationreport)
setwd("~/Dropbox/eyeTrackR Development/Github/eyeTrackR/source/R")
# RANDOM TRIAL TO CHECK THINGS OUT
print(organise.checks.random_trial(fixationreport))
# FIX CONTINGENCIES
organise.contingencies.descriptives(fixationreport)
# FIX CONTINGENCIES
print(organise.contingencies.descriptives(fixationreport))
# REMOVE MISSING EVENTS - HERE, TRIALS WHICH LACKED A RESPOSNE
foo <- organise.message.removals(fixreport_df=fixationreport, required_message_list=list("DISPLAY_CHANGE", "RESPONSE_TIME"))
foo
library(eyeTrackR)
library(eyeTrackR)
# MARKUP UP SAVE FINAL TABLE FOR ANALYSIS
library(eyeTrackR)
# LOAD FILES ##############################################################################################################################################################
#messagereport <- read.table("messagereport.txt", header=T, quote="\"")
#fixreport <- read.table("fixationreport.txt", header=T, quote="\"")
data(fixationreport)
data(messagereport)
# REPLACE SPACES IN MESSAGES
messagereport <- organise.message.replace_spaces(messagereport)
# TAKE A LOOK
print(organise.message.descriptives(messagereport))
# MARKUP
fixationreport <- organise.message.markup(message_df=messagereport, fixreport_df = fixationreport, message="DISPLAY_START")
fixationreport <- organise.message.markup(message_df=messagereport, fixreport_df = fixationreport, message="DISPLAY_CHANGE")
# NOW DO ACCURACY AND RT MARKUP
#foo$CORRECT_ANSWER <- as.numeric(as.character(foo$CORRECT_ANSWER))
fixationreport <- organise.responses.markup(fixationreport, "CORRECT_RESPONSE")
# NOW MARK UP FIXATION CONTINGENCIES
fixationreport<-organise.message.fix_contingencies(fixationreport, list("DISPLAY_START", "DISPLAY_CHANGE", "RESPONSE_TIME"))#, "RESPONSE", "TRIAL_END", "TRIAL_RESULT_0"))
# SET UP TRUE RT
fixationreport[,TRUE_RT:=RESPONSE_TIME-DISPLAY_START,]
behaviouralData <- analyse.behavioural.data(fixationreport,
aggregation_column_list = list('TRIALTYPE_TEXT'))
# RANDOM TRIAL TO CHECK THINGS OUT
print(organise.checks.random_trial(fixationreport))
# FIX CONTINGENCIES
print(organise.contingencies.descriptives(fixationreport))
# REMOVE MISSING EVENTS - HERE, TRIALS WHICH LACKED A RESPOSNE
foo <- organise.message.removals(fixreport_df=fixationreport, required_message_list=list("DISPLAY_CHANGE", "RESPONSE_TIME"))
print(organise.contingencies.descriptives(foo)) # THIS SHOWS WE HAVE NO UNCLASSIFIED FIXATIONS, GOOD!
# REMOVE MISSING EVENTS - HERE, TRIALS WHICH LACKED A RESPOSNE
foo <- organise.message.removals(fixreport_df=fixationreport, required_message_list=list("DISPLAY_CHANGE", "RESPONSE_TIME"))
# REMOVE MISSING EVENTS - HERE, TRIALS WHICH LACKED A RESPOSNE
fixationreport <- organise.message.removals(fixreport_df=fixationreport, required_message_list=list("DISPLAY_CHANGE", "RESPONSE_TIME"))
print(organise.contingencies.descriptives(fixationreport)) # THIS SHOWS WE HAVE NO UNCLASSIFIED FIXATIONS, GOOD!
organise.contingencies.descriptives(fixationreport)
# FIX CONTINGENCIES
print(organise.contingencies.descriptives(fixationreport)[[1]])
# FIX CONTINGENCIES
print(organise.contingencies.descriptives(fixationreport)[[1]][1])
# LOAD FILES ##############################################################################################################################################################
#messagereport <- read.table("messagereport.txt", header=T, quote="\"")
#fixreport <- read.table("fixationreport.txt", header=T, quote="\"")
data(fixationreport)
data(messagereport)
# DO MARKUP ##############################################################################################################################################################
# REPLACE SPACES IN MESSAGES
messagereport <- organise.message.replace_spaces(messagereport)
# TAKE A LOOK
print(organise.message.descriptives(messagereport))
# MARKUP
fixationreport <- organise.message.markup(message_df=messagereport, fixreport_df = fixationreport, message="DISPLAY_START")
fixationreport <- organise.message.markup(message_df=messagereport, fixreport_df = fixationreport, message="DISPLAY_CHANGE")
# NOW DO ACCURACY AND RT MARKUP
#foo$CORRECT_ANSWER <- as.numeric(as.character(foo$CORRECT_ANSWER))
fixationreport <- organise.responses.markup(fixationreport, "CORRECT_RESPONSE")
# NOW MARK UP FIXATION CONTINGENCIES
fixationreport<-organise.message.fix_contingencies(fixationreport, list("DISPLAY_START", "DISPLAY_CHANGE", "RESPONSE_TIME"))#, "RESPONSE", "TRIAL_END", "TRIAL_RESULT_0"))
# SET UP TRUE RT
fixationreport[,TRUE_RT:=RESPONSE_TIME-DISPLAY_START,]
behaviouralData <- analyse.behavioural.data(fixationreport,
aggregation_column_list = list('TRIALTYPE_TEXT'))
# RANDOM TRIAL TO CHECK THINGS OUT
print(organise.checks.random_trial(fixationreport))
#foo[FIXATION_CONTINGENCY=='UNCLASSIFIED',,]
#a <- foo[RECORDING_SESSION_LABEL==13 & TRIAL_INDEX==11,,]
# FIX CONTINGENCIES
print(organise.contingencies.descriptives(fixationreport))
# REMOVE MISSING EVENTS - HERE, TRIALS WHICH LACKED A RESPOSNE
messageRemovals <- organise.message.removals(fixreport_df=fixationreport, required_message_list=list("DISPLAY_CHANGE", "RESPONSE_TIME"))
messageRemovals[1]
print(messageRemovals[2])
# MARKUP UP SAVE FINAL TABLE FOR ANALYSIS
library(eyeTrackR)
# LOAD FILES ##############################################################################################################################################################
#messagereport <- read.table("messagereport.txt", header=T, quote="\"")
#fixreport <- read.table("fixationreport.txt", header=T, quote="\"")
data(fixationreport)
data(messagereport)
# DO MARKUP ##############################################################################################################################################################
# REPLACE SPACES IN MESSAGES
messagereport <- organise.message.replace_spaces(messagereport)
# TAKE A LOOK
print(organise.message.descriptives(messagereport))
# MARKUP
fixationreport <- organise.message.markup(message_df=messagereport, fixreport_df = fixationreport, message="DISPLAY_START")
fixationreport <- organise.message.markup(message_df=messagereport, fixreport_df = fixationreport, message="DISPLAY_CHANGE")
# NOW DO ACCURACY AND RT MARKUP
#foo$CORRECT_ANSWER <- as.numeric(as.character(foo$CORRECT_ANSWER))
fixationreport <- organise.responses.markup(fixationreport, "CORRECT_RESPONSE")
# NOW MARK UP FIXATION CONTINGENCIES
fixationreport<-organise.message.fix_contingencies(fixationreport, list("DISPLAY_START", "DISPLAY_CHANGE", "RESPONSE_TIME"))#, "RESPONSE", "TRIAL_END", "TRIAL_RESULT_0"))
# SET UP TRUE RT
fixationreport[,TRUE_RT:=RESPONSE_TIME-DISPLAY_START,]
behaviouralData <- analyse.behavioural.data(fixationreport,
aggregation_column_list = list('TRIALTYPE_TEXT'))
# RANDOM TRIAL TO CHECK THINGS OUT
print(organise.checks.random_trial(fixationreport))
# FIX CONTINGENCIES
print(organise.contingencies.descriptives(fixationreport))
# REMOVE MISSING EVENTS - HERE, TRIALS WHICH LACKED A RESPONSE
messageRemovals <- organise.message.removals(fixreport_df=fixationreport, required_message_list=list("DISPLAY_CHANGE", "RESPONSE_TIME"))
# LOOK AT MESSAGE REMOVALS
print(messageRemovals[1])
# GRAB THE FIXATION REPORT WITH TRIALS REMOVED
fixMessagesRemoved <- messageRemovals[2]
print(organise.contingencies.descriptives(messageRemovals[2])) # THIS SHOWS WE HAVE NO UNCLASSIFIED FIXATIONS, GOOD!
View(fixMessagesRemoved)
# GRAB THE FIXATION REPORT WITH TRIALS REMOVED
fixMessagesRemoved <- messageRemovals[[2]]
# LOOK AT MESSAGE REMOVALS
print(messageRemovals[[1]])
# GRAB THE FIXATION REPORT WITH TRIALS REMOVED
fixMessagesRemoved <- messageRemovals[[2]]
print(organise.contingencies.descriptives(fixMessagesRemoved)) # THIS SHOWS WE HAVE NO UNCLASSIFIED FIXATIONS, GOOD!
# REMOVALS BASED ON FIXATION DURATIONS
durationRemovals <- organise.exclusions.fix_durations(fixreport_df=fixMessagesRemoved)
durationsRemoved <- durationRemovals[[1]]
finalDT <- durationsRemoved[[2]]
# FINAL DATASET WHICH CAN BE ANALYSED
finalDT <- durationRemovals [[2]]
View(durationsRemoved)
data(fixationreport)
print(organise.checks.random_trial(fixationreport))
# GET A BEHAVIOURAL DATASET FOR ANALYSES AND SAVING ETC.
behavDT<- organise.behavioural.base(fixreport_df = fixMessagesRemoved, list( 'TRIALTYPE_TEXT'),
response_period_start="DISPLAY_START")
View(behavDT)
library(eyeTrackR)
library(eyeTrackR)
library(eyeTrackR)
devtools::check(args = c('--as-cran'), build_args = c('--resave-data','--run-donttest'))
library(eyeTrackR)
moo<- data.table(X=1)
library(data.table)
moo<- data.table(X=1)
mooX <- moo[,Y:=2,]
View(moo)
View(mooX)
View(moo)
# LOAD IA REPORT FOR TESTING
iareport <- fread(file.choose())
# THIS JUST DOES THE MEAN
organise.reading.calculateAverage <- function(ia_df, source_column_name, output_column_name, filterBy, aggregation_column_list){
# REMOVE FULL STOPS AND CONVERT THEM TO NAs
ia_df <- eval(parse(text=paste("ia_df[,", eval(source_column_name), ":=as.numeric(as.character(",eval(source_column_name),")),]", sep='')))
# CALCULATE MEANS GROUPED BY aggregation_column_list
ia_df <- eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(output_column_name), ":=mean(", eval(source_column_name), " [is.na(", eval(source_column_name), ")==F]),", eval(aggregation_column_list), "]", sep='')))
return(ia_df)
}
# THIS DOES THE UPPER AND LOWER SDs
organise.reading.calculateSDs <- function(ia_df, source_column_name, output_column_name, filterBy, sdLimit, aggregation_column_list){
# CALCULATE SD GROUPED BY aggregation_column_list
sd_column_name <- paste(output_column_name, '_SD', sep="")
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(sd_column_name), ":=sd(", eval(source_column_name), " [is.na(", eval(source_column_name), ")==F]),", eval(aggregation_column_list), "]", sep='')))
# CALCULATE UPPER AND LOWER SD BOUNDS
upper_column_name <- paste(sd_column_name, '_UPPER', sep="")
lower_column_name <- paste(sd_column_name, '_LOWER', sep="")
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(upper_column_name), ":=", eval(output_column_name), ' + (',  eval(sdLimit)," * ", eval(sd_column_name), "),", eval(aggregation_column_list), "]", sep='')))
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(lower_column_name), ":=", eval(output_column_name), ' - (',  eval(sdLimit)," * ", eval(sd_column_name), "),", eval(aggregation_column_list), "]", sep='')))
# SET WHICH ONES TO KEEP
keeper_column_name <- paste(output_column_name, '_KEEP', sep='')
eval(parse(text=paste("ia_df[,", eval(keeper_column_name), ":=0,]", sep="")))
# EXPAND FILTER BY TO FIT IN WITH CODE
if (nchar(filterBy)>0){filterBy <- paste(filterBy, ' & ', sep="")}
eval(parse(text=paste("ia_df[", eval(filterBy), "is.na(", eval(source_column_name), ")==F &
(", eval(source_column_name), " < ", eval(lower_column_name), " |
", eval(source_column_name), " > ", eval(upper_column_name), "), ",
eval(keeper_column_name), ":=1,]", sep="")))
return(ia_df)
}
# THIS COMBINES THE OTHERS TOGETHER
organise.reading.calculateRemovals <- function(ia_df, source_column_name, output_column_name, filterBy = '', sdLimit = 3,
aggregation_column_list=list('RECORDING_SESSION_LABEL')){
ia_df <- organise.reading.calculateAverage(ia_df, source_column_name, output_column_name, filterBy, aggregation_column_list)
ia_df <- organise.reading.calculateSDs(ia_df, source_column_name, output_column_name, filterBy, sdLimit, aggregation_column_list)
return(ia_df)
}
##############################################################################################################################################################
# CALCULATE REMOVALS - GENERIC FUNCTION
organise.reading.calculateRemovals <- function(ia_df, source_column_name, output_column_name, filterBy = '', sdLimit = 3,
aggregation_column_list=list('RECORDING_SESSION_LABEL')){
# MEANS FIRST ##############################################################################################################################
# REMOVE FULL STOPS AND CONVERT THEM TO NAs
ia_df <- eval(parse(text=paste("ia_df[,", eval(source_column_name), ":=as.numeric(as.character(",eval(source_column_name),")),]", sep='')))
# CALCULATE MEANS GROUPED BY aggregation_column_list
ia_df <- eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(output_column_name), ":=mean(", eval(source_column_name), " [is.na(", eval(source_column_name), ")==F]),", eval(aggregation_column_list), "]", sep='')))
# SDS NEXT ##############################################################################################################################
# CALCULATE SD GROUPED BY aggregation_column_list
sd_column_name <- paste(output_column_name, '_SD', sep="")
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(sd_column_name), ":=sd(", eval(source_column_name), " [is.na(", eval(source_column_name), ")==F]),", eval(aggregation_column_list), "]", sep='')))
# CALCULATE UPPER AND LOWER SD BOUNDS
upper_column_name <- paste(sd_column_name, '_UPPER', sep="")
lower_column_name <- paste(sd_column_name, '_LOWER', sep="")
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(upper_column_name), ":=", eval(output_column_name), ' + (',  eval(sdLimit)," * ", eval(sd_column_name), "),", eval(aggregation_column_list), "]", sep='')))
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(lower_column_name), ":=", eval(output_column_name), ' - (',  eval(sdLimit)," * ", eval(sd_column_name), "),", eval(aggregation_column_list), "]", sep='')))
# SET WHICH ONES TO KEEP
keeper_column_name <- paste(output_column_name, '_KEEP', sep='')
eval(parse(text=paste("ia_df[,", eval(keeper_column_name), ":=0,]", sep="")))
# EXPAND FILTER BY TO FIT IN WITH CODE
if (nchar(filterBy)>0){filterBy <- paste(filterBy, ' & ', sep="")}
eval(parse(text=paste("ia_df[", eval(filterBy), "is.na(", eval(source_column_name), ")==F &
(", eval(source_column_name), " < ", eval(lower_column_name), " |
", eval(source_column_name), " > ", eval(upper_column_name), "), ",
eval(keeper_column_name), ":=1,]", sep="")))
return(ia_df)
}
# # NOW THE FUNCTIONS ARE SET UP, RUN THIS ONE
# # CHANGE TRIAL INDEX TO SOMETHING THAT YOU WANT LIKE IF YOU WANT THE FIRST TRIAL INDEX ONLY WRITE TRIAL_INDEX
iaDT <- iareport
iaDT <- organise.reading.calculateRemovals(iaDT, source_column_name = 'IA_FIRST_FIXATION_DURATION', output_column_name = 'FFD',
filterBy = ' IA_FIRST_FIX_PROGRESSIVE == 1', sdLimit = 3,
aggregation_column_list=list('RECORDING_SESSION_LABEL')) # THIS IS DOING BY-PARTIIPANT OUTLIERS, CHANGE TO
# A CONDITION COLUMN TO DO IT BY-CONDITION
View(iaDT)
iaDT <- organise.reading.calculateRemovals(iaDT, source_column_name = 'IA_FIRST_FIXATION_DURATION', output_column_name = 'FFD',
filterBy = ' IA_FIRST_FIX_PROGRESSIVE == 1', sdLimit = 3,
aggregation_column_list=list('Participant')) # THIS IS DOING BY-PARTIIPANT OUTLIERS, CHANGE TO
# A CONDITION COLUMN TO DO IT BY-CONDITION
View(iaDT)
##############################################################################################################################################################
# CALCULATE REMOVALS - GENERIC FUNCTION
organise.reading.calculateRemovals <- function(ia_df, source_column_name, output_column_name, filterBy = '', sdLimit = 3,
aggregation_column_list=list('RECORDING_SESSION_LABEL')){
# MEANS FIRST ##############################################################################################################################
# REMOVE FULL STOPS AND CONVERT THEM TO NAs
eval(parse(text=paste("ia_df[,", eval(source_column_name), ":=as.numeric(as.character(",eval(source_column_name),")),]", sep='')))
# CALCULATE MEANS GROUPED BY aggregation_column_list
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(output_column_name), ":=mean(", eval(source_column_name), " [is.na(", eval(source_column_name), ")==F]),", eval(aggregation_column_list), "]", sep='')))
# SDS NEXT ##############################################################################################################################
# CALCULATE SD GROUPED BY aggregation_column_list
sd_column_name <- paste(output_column_name, '_SD', sep="")
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(sd_column_name), ":=sd(", eval(source_column_name), " [is.na(", eval(source_column_name), ")==F]),", eval(aggregation_column_list), "]", sep='')))
# CALCULATE UPPER AND LOWER SD BOUNDS
upper_column_name <- paste(sd_column_name, '_UPPER', sep="")
lower_column_name <- paste(sd_column_name, '_LOWER', sep="")
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(upper_column_name), ":=", eval(output_column_name), ' + (',  eval(sdLimit)," * ", eval(sd_column_name), "),", eval(aggregation_column_list), "]", sep='')))
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(lower_column_name), ":=", eval(output_column_name), ' - (',  eval(sdLimit)," * ", eval(sd_column_name), "),", eval(aggregation_column_list), "]", sep='')))
# SET WHICH ONES TO KEEP
keeper_column_name <- paste(output_column_name, '_KEEP', sep='')
eval(parse(text=paste("ia_df[,", eval(keeper_column_name), ":=0,]", sep="")))
# EXPAND FILTER BY TO FIT IN WITH CODE
if (nchar(filterBy)>0){filterBy <- paste(filterBy, ' & ', sep="")}
eval(parse(text=paste("ia_df[", eval(filterBy), "is.na(", eval(source_column_name), ")==F &
(", eval(source_column_name), " < ", eval(lower_column_name), " |
", eval(source_column_name), " > ", eval(upper_column_name), "), ",
eval(keeper_column_name), ":=1,]", sep="")))
print(paste("ia_df[", eval(filterBy), "is.na(", eval(source_column_name), ")==F &
(", eval(source_column_name), " < ", eval(lower_column_name), " |
", eval(source_column_name), " > ", eval(upper_column_name), "), ",
eval(keeper_column_name), ":=1,]", sep=""))
return(ia_df)
}
# # NOW THE FUNCTIONS ARE SET UP, RUN THIS ONE
# # CHANGE TRIAL INDEX TO SOMETHING THAT YOU WANT LIKE IF YOU WANT THE FIRST TRIAL INDEX ONLY WRITE TRIAL_INDEX
iaDT <- iareport
iaDT <- organise.reading.calculateRemovals(iaDT, source_column_name = 'IA_FIRST_FIXATION_DURATION', output_column_name = 'FFD',
filterBy = ' IA_FIRST_FIX_PROGRESSIVE == 1', sdLimit = 3,
aggregation_column_list=list('Participant')) # THIS IS DOING BY-PARTIIPANT OUTLIERS, CHANGE TO
# A CONDITION COLUMN TO DO IT BY-CONDITION
View(iaDT)
iaDT[ IA_FIRST_FIX_PROGRESSIVE == 1 & is.na(IA_FIRST_FIXATION_DURATION)==F & (IA_FIRST_FIXATION_DURATION < FFD_SD_LOWER | IA_FIRST_FIXATION_DURATION > FFD_SD_UPPER),,]
##############################################################################################################################################################
# CALCULATE REMOVALS - GENERIC FUNCTION
organise.reading.calculateRemovals <- function(ia_df, source_column_name, output_column_name, filterBy = '', sdLimit = 3,
aggregation_column_list=list('RECORDING_SESSION_LABEL')){
# MEANS FIRST ##############################################################################################################################
# REMOVE FULL STOPS AND CONVERT THEM TO NAs
eval(parse(text=paste("ia_df[,", eval(source_column_name), ":=as.numeric(as.character(",eval(source_column_name),")),]", sep='')))
# CALCULATE MEANS GROUPED BY aggregation_column_list
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(output_column_name), ":=mean(", eval(source_column_name), " [is.na(", eval(source_column_name), ")==F]),", eval(aggregation_column_list), "]", sep='')))
# SDS NEXT ##############################################################################################################################
# CALCULATE SD GROUPED BY aggregation_column_list
sd_column_name <- paste(output_column_name, '_SD', sep="")
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(sd_column_name), ":=sd(", eval(source_column_name), " [is.na(", eval(source_column_name), ")==F]),", eval(aggregation_column_list), "]", sep='')))
# CALCULATE UPPER AND LOWER SD BOUNDS
upper_column_name <- paste(sd_column_name, '_UPPER', sep="")
lower_column_name <- paste(sd_column_name, '_LOWER', sep="")
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(upper_column_name), ":=", eval(output_column_name), ' + (',  eval(sdLimit)," * ", eval(sd_column_name), "),", eval(aggregation_column_list), "]", sep='')))
eval(parse(text=paste("ia_df[", eval(filterBy), ",", eval(lower_column_name), ":=", eval(output_column_name), ' - (',  eval(sdLimit)," * ", eval(sd_column_name), "),", eval(aggregation_column_list), "]", sep='')))
# SET WHICH ONES TO KEEP
keeper_column_name <- paste(output_column_name, '_KEEP', sep='')
eval(parse(text=paste("ia_df[,", eval(keeper_column_name), ":=0,]", sep="")))
# EXPAND FILTER BY TO FIT IN WITH CODE
if (nchar(filterBy)>0){filterBy <- paste(filterBy, ' & ', sep="")}
eval(parse(text=paste("ia_df[", eval(filterBy), "is.na(", eval(source_column_name), ")==F &
(", eval(source_column_name), " > ", eval(lower_column_name), " |
", eval(source_column_name), " < ", eval(upper_column_name), "), ",
eval(keeper_column_name), ":=1,]", sep="")))
return(ia_df)
}
# # NOW THE FUNCTIONS ARE SET UP, RUN THIS ONE
# # CHANGE TRIAL INDEX TO SOMETHING THAT YOU WANT LIKE IF YOU WANT THE FIRST TRIAL INDEX ONLY WRITE TRIAL_INDEX
iaDT <- iareport
iaDT <- organise.reading.calculateRemovals(iaDT, source_column_name = 'IA_FIRST_FIXATION_DURATION', output_column_name = 'FFD',
filterBy = ' IA_FIRST_FIX_PROGRESSIVE == 1', sdLimit = 3,
aggregation_column_list=list('Participant')) # THIS IS DOING BY-PARTIIPANT OUTLIERS, CHANGE TO
# A CONDITION COLUMN TO DO IT BY-CONDITION
View(iaDT)
library(eyeTrackR)
library(devtools)
install_github('hjgodwin/eyetrackR/devel')
install_github('hjgodwin/eyetrackR@devel')
install_github(repo = 'hjgodwin/eyeTrackR#devel')
install_github(repo = 'hjgodwin/eyeTrackR-devel')
install_github(repo = 'hjgodwin/eyeTrackR/eyeTrackR-devel')
install_github(repo = 'hjgodwin/eyeTrackR/eyeTrackR-devel/source')
install_github(repo = 'hjgodwin/eyeTrackR@eyeTrackR-devel')
install_github(repo = 'hjgodwin/eyeTrackR@eyeTrackR-devel')
install_github(repo = 'hjgodwin/eyeTrackR@eyeTrackR-devel/source/')
install_github(repo = 'hjgodwin/eyeTrackR/eyeTrackR-devel')
install_github(repo = 'hjgodwin/eyeTrackR@eyeTrackR-devel')
```R
library(devtools)
install_url(url='https://github.com/hjgodwin/eyeTrackR/blob/eyeTrackR-devel/eyeTrackR_1.0.5.tar.gz')
install_github(repo = 'hjgodwin/eyeTrackR/eyeTrackR-devel')
```
Give them a try and let us know what you think! A more detailed guide will be available once the functions are all in place.
install_url(url='https://github.com/hjgodwin/eyeTrackR/blob/eyeTrackR-devel/eyeTrackR_1.0.5.tar.gz')
install_url(url='https://github.com/hjgodwin/eyeTrackR/blob/eyeTrackR-devel/source/')
install_url(url='https://github.com/hjgodwin/eyeTrackR/blob/eyeTrackR-devel/source.zip')
install_url(url='https://github.com/hjgodwin/eyeTrackR/blob/eyeTrackR-devel/source.zip')
library(devtools)
install_github('hjgodwin/eyetrackR/source')
